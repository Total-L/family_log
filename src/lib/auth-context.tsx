"use client";

import React, { createContext, useContext, useState, useEffect } from 'react';
import { User, Story } from './types';
import { useRouter } from 'next/navigation';

interface AuthContextType {
    user: User | null;
    login: (code: string) => boolean;
    logout: () => void;
    isLoading: boolean;
    stories: Story[];
    addStory: (story: Story) => void;
}

const AuthContext = createContext<AuthContextType>({
    user: null,
    login: () => false,
    logout: () => { },
    isLoading: false,
    stories: [],
    addStory: () => { },
});

export function AuthProvider({ children }: { children: React.ReactNode }) {
    const [user, setUser] = useState<User | null>(null);
    const [stories, setStories] = useState<Story[]>([]);
    const router = useRouter();

    // Load stories from Supabase
    useEffect(() => {
        const fetchStories = async () => {
            const { supabase } = await import('./supabase');
            const { data, error } = await supabase
                .from('stories')
                .select('*')
                .order('created_at', { ascending: false });

            if (error) {
                console.error('Error loading stories:', error);
                // Fallback to mock data on error (e.g. table doesn't exist yet)
                import('./data').then((mod) => setStories(mod.MOCK_STORIES));
            } else if (data) {
                // Map DB snake_case to CamelCase if needed, or adjust types. 
                // For MVP, assume DB columns match or we map manually.
                const mappedStories: Story[] = data.map(d => ({
                    id: d.id.toString(),
                    authorId: d.author_id,
                    authorName: d.author_name,
                    authorAvatar: d.author_avatar,
                    content: d.content,
                    imageUrls: d.image_urls || [],
                    likes: d.likes,
                    createdAt: d.created_at,
                    audioUrl: d.audio_url // Assuming we added this column or it exists
                }));
                setStories(mappedStories);
            }
        };

        fetchStories();
    }, []);

    const addStory = async (story: Story) => {
        // Optimistic update
        setStories(prev => [story, ...prev]);

        // Persist to Supabase
        const { supabase } = await import('./supabase');
        // Note: ID is auto-generated by DB, so we don't send it. 
        // We use a simplified insert here.
        const { error } = await supabase.from('stories').insert({
            author_id: story.authorId,
            author_name: story.authorName,
            author_avatar: story.authorAvatar,
            content: story.content,
            image_urls: story.imageUrls,
            likes: story.likes,
        });

        if (error) {
            console.error('Error saving story:', error);
            // Revert or show toast in real app
        }
    };

    // Mock Login Logic
    const login = (code: string) => {
        if (code === '1234') {
            setUser({
                id: 'u1',
                name: '爷爷',
                role: 'senior',
                avatar: '/avatars/grandpa.png',
                bio: '喜欢京剧和下棋'
            });
            router.push('/');
            return true;
        }
        if (code === '5678') {
            setUser({
                id: 'u2',
                name: '王明 (孙子)',
                role: 'family',
                avatar: '/avatars/grandson.png',
            });
            router.push('/');
            return true;
        }
        return false;
    };

    const logout = () => {
        setUser(null);
        router.push('/login');
    };

    return (
        <AuthContext.Provider value={{ user, login, logout, isLoading: false, stories, addStory }}>
            {children}
        </AuthContext.Provider>
    );
}

export const useAuth = () => useContext(AuthContext);
